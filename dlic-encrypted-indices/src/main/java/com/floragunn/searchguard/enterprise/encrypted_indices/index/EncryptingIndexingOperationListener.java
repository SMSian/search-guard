package com.floragunn.searchguard.enterprise.encrypted_indices.index;

import com.floragunn.fluent.collections.ImmutableSet;
import com.floragunn.searchguard.GuiceDependencies;
import com.floragunn.searchguard.enterprise.encrypted_indices.crypto.Cryptor;
import org.apache.lucene.document.Field;
import org.apache.lucene.index.IndexOptions;
import org.apache.lucene.index.IndexableField;
import org.apache.lucene.util.BytesRef;
import org.opensearch.common.bytes.BytesArray;
import org.opensearch.common.bytes.BytesReference;
import org.opensearch.common.xcontent.XContentType;
import org.opensearch.index.IndexService;
import org.opensearch.index.engine.Engine;
import org.opensearch.index.mapper.ParseContext;
import org.opensearch.index.mapper.ParsedDocument;
import org.opensearch.index.mapper.SourceToParse;
import org.opensearch.index.shard.IndexingOperationListener;
import org.opensearch.index.shard.ShardId;
import org.opensearch.indices.IndicesModule;

import java.io.IOException;
import java.util.Arrays;
import java.util.ListIterator;

public class EncryptingIndexingOperationListener implements IndexingOperationListener {

    private final GuiceDependencies guiceDependencies;
    //private Set<String> skipFields = Sets.newHashSet("_id", "_seq_no", "_primary_term", "_version");

    protected static final ImmutableSet<String> META_FIELDS = ImmutableSet.of(IndicesModule.getBuiltInMetadataFields()).without("_source").with("_primary_term");


    public EncryptingIndexingOperationListener(GuiceDependencies guiceDependencies) {
        this.guiceDependencies = guiceDependencies;
    }


    @Override
    public Engine.Index preIndex(ShardId shardId, Engine.Index _operation) {
        //if(operation.isRetry())
        IndexService indexService = guiceDependencies.getIndicesService().indexService(shardId.getIndex());

        if (indexService == null || !indexService.getIndexSettings().getSettings().getAsBoolean("index.encryption_enabled", false)) {
            return _operation;
        }

        ParsedDocument parsedDocument = _operation.parsedDoc();

        new Exception(_operation.origin().name()+" "+shardId.getId()).printStackTrace();

        if(_operation.origin() != Engine.Operation.Origin.PRIMARY){

            BytesReference dec = new BytesArray(Cryptor.dummy().decryptBytesRef(_operation.source().toBytesRef(), "_source"));

            parsedDocument = indexService.mapperService().documentMapper().parse(
                    new SourceToParse(shardId.getIndexName(), _operation.id(),dec , XContentType.JSON, _operation.routing()));


            System.out.println("===!! "+_operation.origin()+" with "+dec.utf8ToString());

            ListIterator<ParseContext.Document> documentListIterator = parsedDocument.docs().listIterator();

            while (documentListIterator.hasNext()) {
                ParseContext.Document document = documentListIterator.next();

                ListIterator<IndexableField> fieldListIterator = document.getFields().listIterator();

                while (fieldListIterator.hasNext()) {



                    IndexableField f = fieldListIterator.next();

                    if(META_FIELDS.contains(f.name())) {
                        continue;
                    }

                    System.out.println(f.name()+"  "+f.fieldType());
                    System.out.println(f.stringValue());
                    System.out.println(f.numericValue());
                    try {
                        System.out.println(f.binaryValue()==null?"":f.binaryValue().utf8ToString());
                    } catch (Throwable e) {
                        if(f.binaryValue() != null)
                        System.out.println(Arrays.toString(f.binaryValue().bytes));
                    }
                }
            }



            //return operation;
        }

        Engine.Index res =
                new Engine.Index(
                        _operation.uid(),
                        parsedDocument,
                        _operation.seqNo(),
                        _operation.primaryTerm(),
                        _operation.version(),
                        _operation.versionType(),
                        _operation.origin(),
                        _operation.startTime(),
                        _operation.getAutoGeneratedIdTimestamp(),
                        _operation.isRetry(),
                        _operation.getIfSeqNo(),
                        _operation.getIfPrimaryTerm());

        System.out.println("###### preIndex "+shardId.getIndex().getUUID()+" "+_operation.isRetry()+" "+_operation.operationType()+" "+_operation.origin());

        encryptSourceField(res);

        ListIterator<ParseContext.Document> documentListIterator = res.docs().listIterator();

        while (documentListIterator.hasNext()) {
            ParseContext.Document document = documentListIterator.next();

            ListIterator<IndexableField> fieldListIterator = document.getFields().listIterator();

            while (fieldListIterator.hasNext()) {

                IndexableField f = fieldListIterator.next();

                if (f instanceof Field) {
                    Field field = (Field) f;
                    try {
                        encryptField(field);
                    } catch (IOException e) {
                        e.printStackTrace();
                        throw new RuntimeException(e);
                    }
                } else {
                    System.out.println("Unhandled field "+f.name()+" "+f.getClass());
                    //TODO
                }
            }


        }





        return res;
    }

    private void encryptField(Field field) throws IOException {

        if(META_FIELDS.contains(field.name())) {
            return;
        }

        System.out.println("encrypt field "+field.name()+" "+field.fieldType()+" "+field.fieldType().indexOptions());

        if (field.fieldType().stored() && field.fieldType().indexOptions() != IndexOptions.NONE) {
            throw new RuntimeException("Stored indexed fields are not supported yet");
        }



        //FieldType fieldType = (FieldType) field.fieldType();
        //fieldType.putAttribute("a","b");

        if (field.fieldType().tokenized() && field.fieldType().indexOptions() != IndexOptions.NONE) {
            //field.tokenStreamValue()
        }

        if (field.fieldType().stored()) {
            if(field.numericValue() != null) {
                Number number = field.numericValue();
                System.out.println("number of type "+number.getClass());


            } if(field.stringValue() != null) {
                field.setStringValue(Cryptor.dummy().encryptString(field.stringValue()));
            } else if (field.readerValue() != null) {
                field.setReaderValue(Cryptor.dummy().encryptReader(field.readerValue()));
            } else if (field.binaryValue() != null) {
                field.setBytesValue(Cryptor.dummy().encryptBytesRef(field.binaryValue(), field.name()));
            } else {
                System.out.println("nix for "+field.getClass());
                throw new RuntimeException();
            }
        }
    }

    private void encryptSourceField(Engine.Index operation) {
        BytesRef source = operation.parsedDoc().source().toBytesRef();
        operation.parsedDoc().setSource(new BytesArray(Cryptor.dummy().encryptBytesRef(source,"_source")), operation.parsedDoc().getXContentType());

//        operation
//                .parsedDoc()
//                .setSource(
//                        new BytesArray(
//                                AES256SIVFormatCrypto.INSTANCE
//                                        .encryptor()
//                                        .crypto(operation.parsedDoc().source().toBytesRef(), "_source")),
//                        operation.parsedDoc().getXContentType());
    }
}
